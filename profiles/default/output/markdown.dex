
import commands; // TODO: remove, needed for BoldNode
import model;

bool simplify_spaces = true;


void write_word(File & f, WordNode & n)
{
  f.write(n.word);
}

void write_eol_node(File & f, EndOfLine & n)
{
  f.write("\n");
}

void write_space_node(File & f, Space & n)
{
  if(simplify_spaces)
	f.write(" ");
  else
	f.write(n.text);
}

void write_group_node(File & f, GroupNode & n)
{
  for(int i(0); i < n.nodes.size(); ++i)
  {
    write_node(f, n.nodes.at(i));
  }
}

void write_bold_node(File & f, BoldNode & n)
{
  f.write("**");
  write_node(f, n.argument);
  f.write("**");
}

void write_type_node(File & f, Type & n)
{
  f.write("`");
  write_node(f, n.argument);
  f.write("`");
}

void write_code_block(File & f, CodeBlock & n)
{
  f.write("```");
  f.write(n.lang);
  simplify_spaces = false;
  write_node(f, n.nodes);
  simplify_spaces = true;
  f.write("```");
}

void write_inline_code(File & f, InlineCode & n)
{
  f.write("`");
  write_node(f, n.argument);
  f.write("`");
}

void write_link(File & f, Link & n)
{
  f.write("[");
  write_node(f, n.text);
  f.write("](");
  write_node(f, n.url);
  f.write(")");
}

void write_list(File & f, ListNode & n)
{
  for (int i(0); i < n.items.size(); ++i)
  {
    f.write("- ");
    write_node(f, n.items.at(i));
    f.write("\n");
  }
}

void write_node(File & f, const Ref<Node> & n)
{
  if(n.is<WordNode>()) {
    write_word(f, n.as<WordNode>());
  } else if(n.is<Space>()) {
	write_space_node(f, n.as<Space>());
  } else if(n.is<EndOfLine>()) {
	write_eol_node(f, n.as<EndOfLine>());
  } else if(n.is<GroupNode>()) {
	write_group_node(f, n.as<GroupNode>());
  } else if(n.is<BoldNode>()) {
	write_bold_node(f, n.as<BoldNode>());
  } else if(n.is<Type>()) {
	write_type_node(f, n.as<Type>());
  } else if(n.is<CodeBlock>()) {
	write_code_block(f, n.as<CodeBlock>());
  } else if(n.is<InlineCode>()) {
	write_inline_code(f, n.as<InlineCode>());
  } else if(n.is<Link>()) {
	write_link(f, n.as<Link>());
  } else if (n.is<ListNode>()) {
    write_list(f, n.as<ListNode>());
  }
}

void write_class(File & f, Class & c)
{
  f.write("# " + c.name + "\n\n");
  
  if(!c.brief.isNull())
  {
    f.write("**Brief:** ");
    write_node(f, c.brief);
  }
  
  f.write("\n\n");
  
  write_node(f, c.description);
  
  f.write("\n\n");
  
  for(int i(0); i < c.functions.size(); ++i)
  {
	write_mem_fun(f, c.functions.at(i));
  }
}

void write_mem_fun(File & f, Function & fun)
{
  f.write("## ");
  write_node(f, fun.name);
  f.write("\n\n");

  if(!fun.brief.isNull())
  {
    f.write("**Brief:** ");
    write_node(f, fun.brief);
	f.write("\n\n");
  }
  
  if(!fun.params.isEmpty())
  {
	f.write("**Parameters:** \n");
	for(int i(0); i < fun.params.size(); ++i)
	{
      f.write("- ");
	  write_node(f, fun.params.at(i));
	  f.write("\n");
	}
	f.write("\n");
  }
  
  if(!fun.returns.isNull())
  {
	f.write("**Returns:** ");
	write_node(f, fun.returns);
	f.write("\n");
  }
  
  if(!fun.description.isNull())
  {
	write_node(f, fun.description); 
  }
  
  
  f.write("\n\n");
}

namespace output
{

void markdown(const String & outdir)
{
  print("Outputing Markdown into :" + outdir);

  
  for(int i(0); i < state.classes.size(); ++i)
  {  
    Class & cla = state.classes.at(i);
    File f{outdir + "/" + cla.name + ".md"};
    if(!f.open(File::WriteOnly))
    {
      print("Could not open output file");
      continue;
    }
	  
    write_class(f, cla);
	f.close();
  }
  
}

} // namespace output