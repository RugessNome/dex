
import node;
import nodes.class;
import nodes.function;
import nodes.code;

class State
{
public:
  State() = default;
  ~State() = default;

  List<Ref<Class>> classes;
  
  List<Ref<Node>> stack;
  
  Ref<Node> current() const
  {
    return stack.back();
  }
  
  Function & currentFunction()
  {
    return stack.back().as<Function>();
  }
  
  void dispatch(const Ref<Node> & node)
  {
	if(stack.isEmpty())
	{
	  if(node.is<Space>() || node.is<EndOfLine>())
	    return;
	
	  print("Error while dispatching node, entity stack is empty");
	  return;
	}
  
    if(stack.back().is<Class>())
    {
      Class & c = stack.back().as<Class>();
	  c.description.get().push_back(node);
    }
	else if(stack.back().is<CodeBlock>())
	{
	  CodeBlock & cb = stack.back().as<CodeBlock>();
	  cb.nodes.get().push_back(node);
	}
  }
  
  void enter(const Ref<Node> & n)
  {
	stack.push_back(n);
  }
  
  Ref<Node> leave()
  {
	Ref<Node> ret = stack.back();
	stack.pop_back();
	return ret;
  }
  
  void beginBlock()
  {
	  
  }
  
  void endBlock()
  {
    while(!stack.empty() && (stack.back().is<Function>()))
	{
      stack.pop_back();
	}
  }
};